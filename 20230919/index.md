# 이더리움
- 스마트 컨트랙트 밒 Dapp 개발을 할 수 있고
- 블록 생성시간 15초~20초까지 스마트 컨트랙트실행이 가능항 환경
- 공급량 제한이 없었는데 어ㅂ스래이드 되면서 공급량이 감소되도록 조정되었다
# 비트코인
- 디지털 화폐로서 전자 지불 수단으로 사용되고
- 블록 생성 시간 10분
- 총 공급량 21백만정도

# 이더리움의 특징

- 이더리움의 특징은 스마트 컨트랙트로 구현할 수 있다.
- 비트코인은 단순히 트랜잭션을 A계정에서 B계정으로 코인을 전송 (누군가 누구에게 전송)
- 이더리움의 경우에는 스마트 컨트랙트를 구현해서 A계정에서 B계정을 통해 C의 상품을 구매할 수 있는 내용을 작성할 수 있다
- B가 A에게 상품의 금액을 전달받고 C에게 알려주면 C는 A에게 상품을 전달하고 A는 C의 상품을 받으면 <br>
스마트 컨트랙트가 동작해서 B의 계정에 C의 계정으로 돈을 송금한다
- 비트코인은 단순히 자산을 전송 이더리움은 조건을 작성할 수 있는 계약의 거래 형태를 `스마트 컨트랙트`라고 부른다
- 스마트 컨트랙트를 활용하면 돈을 전솔하고 받는 거래가 아닌 조건에 맞는 코드를 동작시켜 기능을 추가할 수 있다

- 스마트 컨트랙트 코드는 EVM 이더리움 가상 머신 내부에 저장된다

# EVM 
- 가상머신은 하나의 물리적인 컴퓨터 안에서 다른 운영 체제나 프로그램을 실행할 수 있게 해준다
- 이더리움 가상머신 이더리움 블록체인 네트워크에서 `스마트 컨트랙트` 코드를 작성하고 실행하는데<br>
모든 OS 환경에서 똑같은 코드의 동작이 실행되어야 하고 동일한 결과를 출력해야하기 떄문에<br>
- 이더리움 네트워크는 스마트 컨트랙트 코드를 컴파일 하고 EVM을 톤해 실행시킨다<br>
EVM은 컴파일 된 바이트 코드를 실행 바이트 코드로 컴파일 할 수 있는 코드라면 언어에 상관없이 <br>
EVM을 통해 같은 결과물을 얻을 수 있다

### 1. 스마트 컨트랙트 코드 작성
### 2. 바이트 코드 컴파일
### 3. EVM에서 컴파일한 코드 실행

- 이더리움이 스마트 컨트랙트를 실행할 수 있는 핵심 요소가 EVM (이더리움 가상머신)가산의 컴퓨터가 노드에 존재하기 떄문에<br>
이더리움이 정의한 슈틱에 맞게 스마트 컨트랙트 코드를 실행하고 경과를 상태에 넙데이트 하는 작업을 수행한다

- EVM은 블록체인 분산 네트워크에 참여하고 있는 모든 노드들 같은 상태의 합의를 이룰 수 있도록 내용이 같은 코드를 실헹할 떄 <br>
각자의 실행하는 환경이 달라서 다른 결과물을 얻으면 네트워크는 하나의 상태의 합의를 이룰 수 없다

- 이더리움 네트워크의 모든 노드는 같은 코드를 실행해서 같은 결과를 얻기 위해 EVM 을 실행시킨다. 그래서 모든 노드들을 트랜잭션과 스마트 컨트랙트를 각자의 EVM에서 실행시키고 블록체인의 전체 상태를 다른 노드들과 동일하게 우지시킬 수 있다

# Account

- 이더리움 네트워크에 EOA와 CA라는 두 계념이 있고 각각의 역할은 

## EOA는  : 외부 소유 계정

### 1. 개인키가 있고 지갑 계정으로 코드 저장 X

### 2. 자금 또는 스마트 컨트랙트의 접근을 제어

### 3. EOA에서 트랜잭션 생성

### EOA 다른 EOA 또는 CA에 트랜잭션을 보낼 수 있고 개인키를 사용해서 트랜잭션을 생성 서명.

### EOA에서 다른 EOA로 전송하면 돈 전송

### EOA에서 CA로 트랜잭션을 생성하면 CA의 코드를 동작시킨다. (EOA -> CA) EOA가 전송한 트랜잭션을 시작된다(CA->X)

### CA : 계약의 주소

### 1. 스마트 컨트랙트 로직으로 스마트 컨트랙트 코드를 해시 내용으로 저장

### 2. 개인키가 없고 스스로 트랜잭션을 발생시킬 수 없다

### 3. 외부 트랜잭션의 응답으로 트랜잭션을 실행할 수 있다

### CA는 EOA와 다르게 개인키가 없고 스스로 트랜잭션을 생성할 수 없다

### CA ->EOA(X)

### EOA -> CA (O)

### CA는 다른 ㅊㅁSK EOA에서 받은 트랜잭션의 응답으로 트ㅐㄹㄴ잭션을 실행할 수 있다

### EOA -> EOA (금액 전송)

### EOA -> CA (스마트 개약 코드를 실행)(트랜잭션 처리-> EVM 을 통해 스마트 컨트랙트 코드를 실행)

### EOA (외부 소유 계정) 

### 트랜잭션의 객체의 구성은
- from : 보내는 계정
- to : 받는 계정 
- nonce : 보내는 계정이 발생시킨 트랜잭션 횟수<br>
(EOA계쩡이 생성되면 0) <br>
(트랜잭션을 발생시킬떄 마다 증가)<br>
예) 트랜잭션 1 : nonce :1<br>
예) 트랜잭션 2 : nonce :2<br>
예) 트랜잭션 3 : nonce :3<br>
중복되지 않고 순차적으로 트랜잭션을 처리하기 위해서 <br>
어떤 트랜잭션을 우선적으로 처리할 지 결정하기 위해 nonce를 사용<br>
우선순위 결정을 할때 nonce와 가스비를 함꼐 사용해서 우선순위를 결정 <br>
이중 지불 문제를 방지하기 위해 사용

- value : 보내는 금액
- gasLimit : 해당 트랜잭젼의 사용할 수 있는 최대치
- gasgprice : 보내는 사람이 지불하는 가스당의 가격 수수료
- data : 스마트 계약의 주소와 함수를 호출하는 내용에 필여한 매개변수

# 테스트 코드 작성

1. 지갑을 생성을 하고
// 공개키와 개인키를 생성
// 지갑 1개 생성이 되어있는 상태

2. 지갑 주소로 블록을 생성 (마이닝)
// 블록을 채굴할 때 보상 트랜잭션 내용을 만드는데
3. 블록의 채굴 보상을 이 지갑이 받고(코인 베이스 트랜잭션 블록 추가)
// 블록의 다음번 높이 값이 IN
// {주소 : 보상}
// 블록생성 연산을 통해 POW로 연산을 통해 블록 생성권한을 얻을때
// 블록 생성을 하고
// txout에 있는 {처음에 만든 지갑 ㅈ주소 : 보상} utxo에 담고


4. UTXO 채굴자 지갑의 계정과 블록 채굴 보상

5. 새로운 지갑을 하나 더 만들어서
// 하나의 지갑 또 생성
// 공개키 개인키 생성
// 처음에 만든 지갑으로 트랜잭션을 생성
// 첫번째 지갑에서 -> 두번째 지갑으로 코인 전송
// 개인키로 서명을 하고
// 서명의 내용과 보내는 사람 받는 사람 전송 금액 UTXO 첫번째 지갑의 잔액을 조회해서
// 트랜잭션 풀에 담겨있고 트랜잭션 대기상태

6. 채굴 보상을 받은 지갑에서 새로운 지갑으로 돈을 송금 트랜잭션을 발생
7. 서명이 유효한지 검증을 거치고 트랜잭션 풀에 담아놓고
8. 새로운 지갑이 블록 마이닝해서(코인베이스 트랜잭션을 추가)(트랜잭션 풀에있는 트랜잭션을 처리)
// 두번째 지갑의 주소로
// 코인베이스 트랜잭션, 트랜잭션 풀에 있는 대기상의 트랜잭션 내용
// 블록을 마이닝
// 블록을 추가 츠랜잭션 풀에 있는 처리된 트랜잭션을 제거{첫번째 지갑: 남은 금액}, {두번째 지갑 : 받은 금액}
//UTXO Pool에 담고


9. utxo에 처음 만든 지갑이 전솔한 잔액이 새로운 지갑에 잔액으로 미사용 객체가 추가가 될 수 있게
// 첫번째 지갑의 잔액 조회
// 두번쨰 지갑의 잔액 조회
// 